[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "association.html",
    "href": "association.html",
    "title": "Association analysis",
    "section": "",
    "text": "While Findr.jl is developed primarily for causal inference from genomics and transcriptomics data, association analysis between genomics and transcriptomics data is also possible. In association analysis, genetic effects on the transcriptome are measured by testing if genes are differentially expressed in different groups of samples defined by the genotype of a genetic variant of interest. In Findr.jl, significance of association is computed using a categorical model and a variant-specific background distribution. Similar to what was done in the coexpression analysis tutorial, this is achieved by modelling the distribution of association values between a given variant \\(A\\) and all genes \\(B\\) as a mixture distribution of real and null (random) associations. The relative weight of each component then reflects the prior probability of finding a non-null \\(B\\) gene for a given variant \\(A\\), and is fitted for every \\(A\\) separately.\nWe will illustrate how to run association analysis with Findr.jl using preprocessed data from the GEUVADIS study. See the installation instructions for the steps you need to take to reproduce this tutorial."
  },
  {
    "objectID": "association.html#introduction",
    "href": "association.html#introduction",
    "title": "Association analysis",
    "section": "",
    "text": "While Findr.jl is developed primarily for causal inference from genomics and transcriptomics data, association analysis between genomics and transcriptomics data is also possible. In association analysis, genetic effects on the transcriptome are measured by testing if genes are differentially expressed in different groups of samples defined by the genotype of a genetic variant of interest. In Findr.jl, significance of association is computed using a categorical model and a variant-specific background distribution. Similar to what was done in the coexpression analysis tutorial, this is achieved by modelling the distribution of association values between a given variant \\(A\\) and all genes \\(B\\) as a mixture distribution of real and null (random) associations. The relative weight of each component then reflects the prior probability of finding a non-null \\(B\\) gene for a given variant \\(A\\), and is fitted for every \\(A\\) separately.\nWe will illustrate how to run association analysis with Findr.jl using preprocessed data from the GEUVADIS study. See the installation instructions for the steps you need to take to reproduce this tutorial."
  },
  {
    "objectID": "association.html#set-up-the-environment",
    "href": "association.html#set-up-the-environment",
    "title": "Association analysis",
    "section": "Set up the environment",
    "text": "Set up the environment\nWe begin by setting up the environment and loading some necessary packages.\n\nusing DrWatson\nquickactivate(@__DIR__)\n\nusing DataFrames\nusing Arrow\n\nusing Findr"
  },
  {
    "objectID": "association.html#load-data",
    "href": "association.html#load-data",
    "title": "Association analysis",
    "section": "Load data",
    "text": "Load data\n\nExpression data\nFindr.jl expects that expression data are stored as floating-point numbers in a DataFrame where columns correspond to variables (genes) and rows to samples, see the coexpression analysis tutorial for more details.\nThis tutorial uses two tables of expression data from the same set of samples, one for mRNA expression data called dt, and one for microRNA (miRNA) expression data called dm:\n\ndt = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dt.arrow\")));\ndm = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dm.arrow\")));\n\n\n\nGenotype data\nFindr.jl expects that genotype data are stored as integer numbers in a DataFrame where columns correspond to variables (genetic variants) and rows to samples. Since Findr.jl uses a categorical association model, it does not matter how different genotypes (e.g. heterozygous vs. homozygous) are encoded as integers. Future versions will support scientific types for representing genotype data.\nThis tutorial uses two tables of genotype data from the same set of samples as the expression data, one with genotypes for mRNA eQTLs called dgt, and one for microRNA (miRNA) eQTLs called dgm:\n\ndgt = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dgt.arrow\")));\ndgm = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dgm.arrow\")));"
  },
  {
    "objectID": "association.html#run-findr.jl",
    "href": "association.html#run-findr.jl",
    "title": "Association analysis",
    "section": "Run Findr.jl",
    "text": "Run Findr.jl\nAssume we are interested in identifying mRNA genes whose expression levels are associated to microRNA eQTLs. We run:\n\ndP = findr(dt, dgm, FDR=0.05)\n\n79×4 DataFrame54 rows omitted\n\n\n\nRow\nSource\nTarget\nProbability\nqvalue\n\n\n\nString\nString\nFloat64\nFloat64\n\n\n\n\n1\nrs71532525\nENSG00000229358.2\n1.0\n0.0\n\n\n2\nrs6987762\nENSG00000245080.3\n1.0\n0.0\n\n\n3\nrs3807344\nENSG00000128510.5\n1.0\n0.0\n\n\n4\nrs6462386\nENSG00000229358.2\n1.0\n0.0\n\n\n5\nrs3807344_1\nENSG00000128510.5\n1.0\n0.0\n\n\n6\nrs9616333\nENSG00000212939.2\n1.0\n4.48436e-11\n\n\n7\nrs8141807\nENSG00000212939.2\n1.0\n2.89877e-10\n\n\n8\nrs6462386\nENSG00000237004.2\n1.0\n3.02056e-8\n\n\n9\nrs71532525\nENSG00000237004.2\n1.0\n6.69088e-8\n\n\n10\nrs57011695\nENSG00000178381.7\n0.999999\n1.37072e-7\n\n\n11\nrs5743580\nENSG00000174130.7\n0.999339\n6.02461e-5\n\n\n12\nrs2273626\nENSG00000092036.12\n0.998865\n0.000149778\n\n\n13\nrs5743580\nENSG00000174125.3\n0.998755\n0.000234037\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n68\nrs80283015\nENSG00000101940.11\n0.890005\n0.0368456\n\n\n69\nrs80283015\nENSG00000137142.4\n0.883123\n0.0380055\n\n\n70\nrs768533\nENSG00000100239.10\n0.878592\n0.0391969\n\n\n71\nrs768533_1\nENSG00000100239.10\n0.878592\n0.0403548\n\n\n72\nrs80283015\nENSG00000204116.6\n0.87547\n0.0415239\n\n\n73\nrs768533\nENSG00000135211.5\n0.873795\n0.0426839\n\n\n74\nrs768533_1\nENSG00000135211.5\n0.873795\n0.0438126\n\n\n75\nrs2961920\nENSG00000198018.6\n0.869798\n0.0449645\n\n\n76\nrs768533\nENSG00000186283.9\n0.869478\n0.0460902\n\n\n77\nrs768533_1\nENSG00000186283.9\n0.869478\n0.0471867\n\n\n78\nrs80283015\nENSG00000170006.7\n0.868594\n0.0482665\n\n\n79\nrs768533\nENSG00000177455.6\n0.867495\n0.0493328\n\n\n\n\n\n\nFindr computes a posterior probability of non-zero association for every Source variant (columns of dgm) and Target gene (columns of dt). By default the output is sorted by decreasing Probability. The optional parameter FDR can be used to limit the output to the set of pairs that has a global false discovery rate (FDR) less than a desired value (here set to 5%). The qvalue column in the output can be used for further filtering of the output, see the coexpression analysis tutorial for further details.\nNote the order of the arguments. The first argument dt is the Target DataFrame, and the second argument the Source DataFrame."
  },
  {
    "objectID": "causal-inference.html",
    "href": "causal-inference.html",
    "title": "Causal inference",
    "section": "",
    "text": "The primary use of Findr.jl is for causal inference from genomics and transcriptomics data. In causal inference, cis-acting eQTLs are used as causal anchors or instrumental variables to orient the direction of causality between coexpressed genes, see the Findr paper for more details. As in coexpression analysis and association analysis, the significance of a causal effect is computed using a gene-specific background distribution. This is again achieved by modelling the distribution of test statistics between a given gene \\(A\\) and all other genes \\(B\\) as a mixture distribution of real and null (random) correlations. The relative weight of each component reflects the prior probability of finding a non-null \\(B\\) gene for a given \\(A\\) gene, and is fitted for every \\(A\\) gene separately.\nUnlike in coexpression analysis and association analysis, causal inference cannot be performed using a single statistical test, but requires the combination of multiple tests. In Findr.jl, six likelihood ratio tests are implemented, which can be combined in multiple ways for causal inference. Tests are combined by addition or mulitplication of the posterior probabilities of individial tests, an approach first proposed in this paper.\nWe will illustrate how to run causal inference with Findr.jl using preprocessed data from the GEUVADIS study. See the installation instructions for the steps you need to take to reproduce this tutorial."
  },
  {
    "objectID": "causal-inference.html#introduction",
    "href": "causal-inference.html#introduction",
    "title": "Causal inference",
    "section": "",
    "text": "The primary use of Findr.jl is for causal inference from genomics and transcriptomics data. In causal inference, cis-acting eQTLs are used as causal anchors or instrumental variables to orient the direction of causality between coexpressed genes, see the Findr paper for more details. As in coexpression analysis and association analysis, the significance of a causal effect is computed using a gene-specific background distribution. This is again achieved by modelling the distribution of test statistics between a given gene \\(A\\) and all other genes \\(B\\) as a mixture distribution of real and null (random) correlations. The relative weight of each component reflects the prior probability of finding a non-null \\(B\\) gene for a given \\(A\\) gene, and is fitted for every \\(A\\) gene separately.\nUnlike in coexpression analysis and association analysis, causal inference cannot be performed using a single statistical test, but requires the combination of multiple tests. In Findr.jl, six likelihood ratio tests are implemented, which can be combined in multiple ways for causal inference. Tests are combined by addition or mulitplication of the posterior probabilities of individial tests, an approach first proposed in this paper.\nWe will illustrate how to run causal inference with Findr.jl using preprocessed data from the GEUVADIS study. See the installation instructions for the steps you need to take to reproduce this tutorial."
  },
  {
    "objectID": "causal-inference.html#set-up-the-environment",
    "href": "causal-inference.html#set-up-the-environment",
    "title": "Causal inference",
    "section": "Set up the environment",
    "text": "Set up the environment\n\nusing DrWatson\nquickactivate(@__DIR__)\n\nusing DataFrames\nusing Arrow\n\nusing Findr"
  },
  {
    "objectID": "causal-inference.html#load-data",
    "href": "causal-inference.html#load-data",
    "title": "Causal inference",
    "section": "Load data",
    "text": "Load data\n\nExpression data\nFindr.jl expects that expression data are stored as floating-point numbers in a DataFrame where columns correspond to variables (genes) and rows to samples, see the coexpression analysis tutorial for more details.\nThis tutorial uses two tables of expression data from the same set of samples, one for mRNA expression data called dt, and one for microRNA (miRNA) expression data called dm:\n\ndt = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dt.arrow\")));\ndm = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dm.arrow\")));\n\n\n\nGenotype data\nFindr.jl expects that genotype data are stored as integer numbers in a DataFrame where columns correspond to variables (genetic variants) and rows to samples. Findr.jl uses a categorical model to associate genetic variation to variation in gene expression, hence how different genotypes (e.g. heterozygous vs. homozygous) are encoded as integers does not matter. Future versions will support scientific types for representing genotype data.\nThis tutorial uses two tables of expression data from the same set of samples, one with genotypes for mRNA eQTLs called dgt, and one for microRNA (miRNA) eQTLs called dgm:\n\ndgt = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dgt.arrow\")));\ndgm = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dgm.arrow\")));\n\n\n\neQTL mapping data\nThe preprocessed GEUVADIS data has been organized such that each column of the genotype data is the strongest eQTLs for the corresponding column in the matching expression data. Usually however, eQTL mapping data will be available in the form of a table with variant IDs, gene IDs, and various eQTL associaion statistics (see the original GEUVADIS file for an example). Findr.jl expects that such a table is read into a DataFrame, and that only the best (most strongly associated) eQTL is kept for each gene, that is, genes appear only once in the eQTL mapping table. Let’s artificially create such tables for our data:\n\ndpt = DataFrame(SNP_ID = names(dgt), GENE_ID=names(dt)[1:ncol(dgt)]);\ndpm = DataFrame(SNP_ID = names(dgm), GENE_ID=names(dm)[1:ncol(dgm)]);"
  },
  {
    "objectID": "causal-inference.html#run-findr.jl",
    "href": "causal-inference.html#run-findr.jl",
    "title": "Causal inference",
    "section": "Run Findr.jl",
    "text": "Run Findr.jl\n\nSubset-to-all causal inference\nIn the most common scenario, we have a dataset of gene expression values, with significant cis-eQTL instruments for a subset of genes (“eGenes”). We can then infer causal interactions from the eGenes to all other genes (including other eGenes). For instance, to infer causal microRNA \\(\\to\\) microRNA interaction, run:\n\ndP = findr(dm, dgm, dpm; FDR=0.1)\n\n36×4 DataFrame11 rows omitted\n\n\n\nRow\nSource\nTarget\nProbability\nqvalue\n\n\n\nString\nString\nFloat64\nFloat64\n\n\n\n\n1\nhsa-miR-550a-2-5p\nhsa-miR-550a-3-5p\n1.0\n0.0\n\n\n2\nhsa-miR-96-5p\nhsa-miR-182-5p\n1.0\n4.82947e-13\n\n\n3\nhsa-miR-550a-2-5p\nhsa-miR-550a-2-3p\n1.0\n2.533e-11\n\n\n4\nhsa-miR-550a-2-3p\nhsa-miR-550a-3-5p\n1.0\n1.43622e-10\n\n\n5\nhsa-miR-3130-1-5p\nhsa-miR-3130-2-5p\n1.0\n3.59833e-10\n\n\n6\nhsa-miR-550a-2-3p\nhsa-miR-550a-2-5p\n1.0\n8.07521e-10\n\n\n7\nhsa-miR-183-5p\nhsa-miR-182-5p\n1.0\n5.92158e-9\n\n\n8\nhsa-miR-30a-3p\nhsa-miR-30a-5p\n1.0\n4.33738e-8\n\n\n9\nhsa-miR-335-5p\nhsa-miR-335-3p\n0.999997\n3.78462e-7\n\n\n10\nhsa-miR-30a-5p\nhsa-miR-30a-3p\n0.999986\n1.69667e-6\n\n\n11\nhsa-miR-200a-3p\nhsa-miR-200b-3p\n0.999978\n3.55899e-6\n\n\n12\nhsa-miR-574-5p\nhsa-miR-574-3p\n0.999977\n5.18541e-6\n\n\n13\nhsa-miR-335-3p\nhsa-miR-335-5p\n0.999935\n9.80113e-6\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n25\nhsa-miR-3176-3p\nhsa-miR-19b-1-3p\n0.858206\n0.0265815\n\n\n26\nhsa-miR-3176-3p\nhsa-miR-548ac-5p\n0.820578\n0.03246\n\n\n27\nhsa-miR-3176-3p\nhsa-miR-19a-3p\n0.771053\n0.0397373\n\n\n28\nhsa-miR-339-5p\nhsa-miR-339-3p\n0.746762\n0.0473623\n\n\n29\nhsa-miR-1304-3p\nhsa-miR-548ar-5p\n0.746114\n0.0544838\n\n\n30\nhsa-miR-193b-3p\nhsa-miR-345-5p\n0.73682\n0.0614403\n\n\n31\nhsa-miR-1304-3p\nhsa-miR-194-2-5p\n0.736664\n0.0679531\n\n\n32\nhsa-let-7b-5p\nhsa-let-7b-3p\n0.734285\n0.0741332\n\n\n33\nhsa-miR-1307-5p\nhsa-miR-1307-3p\n0.718379\n0.0804207\n\n\n34\nhsa-miR-1304-3p\nhsa-miR-194-1-5p\n0.714601\n0.0864494\n\n\n35\nhsa-miR-3176-3p\nhsa-miR-3181-5p\n0.708352\n0.0923123\n\n\n36\nhsa-miR-3176-3p\nhsa-miR-24-1-3p\n0.705673\n0.0979238\n\n\n\n\n\n\nFindr computes a posterior probability of a non-zero causal interaction for every pair pf Source and Target genes (columns of dm). The possible Source genes are the eGenes, the subset of genes with cis-eQTLs (columns of dgm), as defined by the eQTL-to-gene mapping in dpm.\nBy default the output is sorted by decreasing Probability. The optional parameter FDR can be used to limit the output to the set of pairs that has a global false discovery rate (FDR) less than a desired value (here set to 10%). The qvalue column in the output can be used for further filtering of the output, see the coexpression analysis tutorial for more details.\nNote the order of input arguments: first dm, the expression data, then dgm, the genotype data, and then dpm, the eQTL mapping of variants to eGenes.\nBy default, Findr assumes that the first column of dpm is a list of variant names that can be found in the column names of dgm, and that the second column of dpm is a list of gene names that can be found in the column names of dm:\n\ndpm\n\n55×2 DataFrame30 rows omitted\n\n\n\nRow\nSNP_ID\nGENE_ID\n\n\n\nString\nString\n\n\n\n\n1\nrs201731283\nhsa-miR-4804-5p\n\n\n2\nrs73933236\nhsa-miR-641-5p\n\n\n3\nrs17269517\nhsa-miR-2116-3p\n\n\n4\nrs2273626\nhsa-miR-4707-3p\n\n\n5\nrs174559\nhsa-miR-1908-5p\n\n\n6\nrs7095504\nhsa-miR-2110-5p\n\n\n7\nrs2583391\nhsa-miR-1255a-5p\n\n\n8\nrs5743580\nhsa-miR-574-3p\n\n\n9\nrs143756085\nhsa-miR-1270-2-5p\n\n\n10\nrs17269517_1\nhsa-miR-2116-5p\n\n\n11\nrs11191968\nhsa-miR-4482-1-3p\n\n\n12\nrs8141807\nhsa-miR-3667-5p\n\n\n13\nrs648571\nhsa-miR-5680-3p\n\n\n⋮\n⋮\n⋮\n\n\n44\nrs1378942\nhsa-miR-4513-5p\n\n\n45\nrs768533_1\nhsa-miR-3130-1-5p\n\n\n46\nrs78562044\nhsa-miR-30a-3p\n\n\n47\nrs35671783\nhsa-miR-1304-3p\n\n\n48\nrs2537621\nhsa-miR-589-5p\n\n\n49\nrs6462386\nhsa-miR-550a-2-3p\n\n\n50\nrs745666\nhsa-miR-3615-3p\n\n\n51\nrs817478\nhsa-miR-4423-5p\n\n\n52\nrs73054305\nhsa-miR-642a-5p\n\n\n53\nrs3807344_1\nhsa-miR-335-3p\n\n\n54\nrs4393680\nhsa-miR-4741-3p\n\n\n55\nrs2583392\nhsa-miR-1255a-3p\n\n\n\n\n\n\nIf your eQTL mapping DataFrame has the relevant columns in a different place, you need to use the optional arguments colX (for the gene expression IDs) and colG (for the eQTL genotype IDs) to specify either the relevant columns index or name:\n\ndP = findr(dm, dgm, dpm; colX=2, colG=1, FDR=0.1);\n\nor\n\ndP = findr(dm, dgm, dpm; colX=\"GENE_ID\", colG=\"SNP_ID\", FDR=0.1);\n\nAny other columns in the eQTL mapping DataFrame (such as association summary statistics) are ignored.\n\n\nBipartite causal inference\nIn some applications, we have multiple omics datasets from the same samples, and may be interested in causal inference from one set of variables to another one. In the GEUVADIS study for instance, we may be interested in inferring causal interactions between microRNAs and target genes. To infer interactions from microRNAs to mRNAs, run:\n\ndP = findr(dt, dm, dgm, dpm; FDR=0.1)\n\n22×4 DataFrame\n\n\n\nRow\nSource\nTarget\nProbability\nqvalue\n\n\n\nString\nString\nFloat64\nFloat64\n\n\n\n\n1\nhsa-miR-335-3p\nENSG00000128510.5\n1.0\n0.0\n\n\n2\nhsa-miR-335-5p\nENSG00000128510.5\n1.0\n1.11022e-16\n\n\n3\nhsa-miR-3150b-3p\nENSG00000245080.3\n1.0\n1.52987e-7\n\n\n4\nhsa-miR-3150b-3p\nENSG00000175895.3\n0.997247\n0.000688348\n\n\n5\nhsa-miR-335-5p\nENSG00000106484.8\n0.991704\n0.00220981\n\n\n6\nhsa-miR-335-3p\nENSG00000106484.8\n0.991704\n0.00322411\n\n\n7\nhsa-miR-339-5p\nENSG00000224079.1\n0.989118\n0.00431814\n\n\n8\nhsa-miR-574-3p\nENSG00000197712.6\n0.981865\n0.00604525\n\n\n9\nhsa-let-7b-5p\nENSG00000241990.1\n0.976618\n0.0079715\n\n\n10\nhsa-let-7b-5p\nENSG00000197182.8\n0.946246\n0.0125498\n\n\n11\nhsa-miR-574-5p\nENSG00000197712.6\n0.930644\n0.017714\n\n\n12\nhsa-miR-335-5p\nENSG00000220884.2\n0.92274\n0.0226762\n\n\n13\nhsa-miR-335-3p\nENSG00000220884.2\n0.92274\n0.026875\n\n\n14\nhsa-miR-1270-2-5p\nENSG00000231205.6\n0.892731\n0.0326174\n\n\n15\nhsa-miR-335-3p\nENSG00000158516.7\n0.848667\n0.0405318\n\n\n16\nhsa-miR-335-5p\nENSG00000158516.7\n0.848667\n0.0474568\n\n\n17\nhsa-miR-574-5p\nENSG00000174123.6\n0.837448\n0.0542271\n\n\n18\nhsa-miR-550a-2-3p\nENSG00000229358.2\n0.833727\n0.0604519\n\n\n19\nhsa-miR-30a-5p\nENSG00000169220.12\n0.830649\n0.0661834\n\n\n20\nhsa-miR-1908-5p\nENSG00000134824.9\n0.786188\n0.0735649\n\n\n21\nhsa-miR-30a-5p\nENSG00000231588.1\n0.770527\n0.0809891\n\n\n22\nhsa-miR-345-5p\nENSG00000258504.1\n0.694279\n0.0912041\n\n\n\n\n\n\n\n\nCausal test combinations\nAs indicated above, causal inference requires the combination of multiple statistical tests, and Findr.jl supports multiple such combinations, each with their own strengths and weaknesses. Comparisons between the different methods can be found in the original Findr paper and in a follow-up paper. In brief, the following combinations are available:\n\nInstrumental variables (default)\nThe instrumental variables (IV) test combination infers a causal \\(A\\to B\\) interaction if there is a genetic association \\(E\\to B\\), where \\(E\\) is the causal anchor (best cis-eQTL for \\(A\\)), and if \\(A\\) and \\(B\\) are not independently associated with \\(E\\) (no pleiotropic effect). This test combination has been shown to provide a good balance between false negative and false positive rate and has a clear genetic interpretation. It is therefore recommended as the default combination. To use the instrumental variable test combination, you don’t need to do anything (it’s the default):\n\ndP = findr(dm, dgm, dpm; FDR=0.1);\n\nor, you can explicitly set the optional parameter combination=\"IV\":\n\ndP = findr(dm, dgm, dpm; FDR=0.1, combination=\"IV\");\n\n\n\nMediation\nThe mediation test infers a causal \\(A\\to B\\) interaction if there is a genetic association \\(E\\to B\\) and if this association disappears after conditioning on \\(A\\). If these two tests are true, the causal graph must be \\(E\\to A\\to B\\). As a result, this test combination has a very low false positive rate, but in most applications it is hampered by a high false negative rate: if \\(A\\) and \\(B\\) are jointly regulated by a third factor \\(C\\), the mediation test will fail even in the presence of a true \\(A\\to B\\) interaction. To use the mediation test combination, set the optional parameter combination=\"mediation\":\n\ndP_med = findr(dm, dgm, dpm; FDR=0.1, combination=\"mediation\");\n\n\n\nOriginal Findr combination\nIn the original Findr paper, a new test combination was proposed that combines the instrumental variable test combination with a new relevance test. On simulated data, this new combination further reduced the false negative rate compared to the IV combination. at the expense of an increased false positive rate, for an overall improved performance. However, the relevance test does not have a clear genetic or causal interpretation, and on real data, performance is generally equivalent to the IV combination, and therefore the IV combination is now recommended as the default. To use the original Findr test combination, set the optional parameter combination=\"orig\":\n\ndP_orig = findr(dm, dgm, dpm; FDR=0.1, combination=\"orig\");"
  },
  {
    "objectID": "coexpression.html",
    "href": "coexpression.html",
    "title": "Coexpression analysis",
    "section": "",
    "text": "While Findr.jl is developed primarily for causal inference from genomics and transcriptomics data, coexpression analysis of transcriptomics data alone is also possible. In coexpression analysis, pairwise correlation is used as a simple measure for the probability of two genes being functionally related either through direct or indirect regulation, or through coregulation by a third factor. In Findr.jl, significance of pairwise correlation is computed using a gene-specific background distribution, allowing for genes having different biological roles. For instance, it is known that many biological networks are scale-free, where a small number of so-called “hub genes” have a high number of interaction partners while most other genes only have few. In Findr.jl, this is accomodated by modelling the distribution of correlation values between a given gene \\(A\\) and all other genes \\(B\\) as a mixture distribution of real and null (random) correlations. The relative weight of each component reflects the prior probability of finding a non-null \\(B\\) gene for a given \\(A\\) gene, and is fitted for every \\(A\\) gene separately.\nWe will illustrate how to run coexpression analysis with Findr.jl using preprocessed data from the GEUVADIS study. See the installation instructions for the steps you need to take to reproduce this tutorial."
  },
  {
    "objectID": "coexpression.html#introduction",
    "href": "coexpression.html#introduction",
    "title": "Coexpression analysis",
    "section": "",
    "text": "While Findr.jl is developed primarily for causal inference from genomics and transcriptomics data, coexpression analysis of transcriptomics data alone is also possible. In coexpression analysis, pairwise correlation is used as a simple measure for the probability of two genes being functionally related either through direct or indirect regulation, or through coregulation by a third factor. In Findr.jl, significance of pairwise correlation is computed using a gene-specific background distribution, allowing for genes having different biological roles. For instance, it is known that many biological networks are scale-free, where a small number of so-called “hub genes” have a high number of interaction partners while most other genes only have few. In Findr.jl, this is accomodated by modelling the distribution of correlation values between a given gene \\(A\\) and all other genes \\(B\\) as a mixture distribution of real and null (random) correlations. The relative weight of each component reflects the prior probability of finding a non-null \\(B\\) gene for a given \\(A\\) gene, and is fitted for every \\(A\\) gene separately.\nWe will illustrate how to run coexpression analysis with Findr.jl using preprocessed data from the GEUVADIS study. See the installation instructions for the steps you need to take to reproduce this tutorial."
  },
  {
    "objectID": "coexpression.html#set-up-the-environment",
    "href": "coexpression.html#set-up-the-environment",
    "title": "Coexpression analysis",
    "section": "Set up the environment",
    "text": "Set up the environment\nWe begin by setting up the environment and loading some necessary packages.\n\nusing DrWatson\nquickactivate(@__DIR__)\n\nusing DataFrames\nusing Arrow\nusing Markdown\n\nusing Findr"
  },
  {
    "objectID": "coexpression.html#load-expression-data",
    "href": "coexpression.html#load-expression-data",
    "title": "Coexpression analysis",
    "section": "Load expression data",
    "text": "Load expression data\nFindr.jl expects that expression data are stored in a DataFrame where columns correspond to variables (genes) and rows to samples. An expression DataFrame should not contain any other columns (e.g. gene annotation) than gene expression columns, and gene expression data should be stored as floating-point numbers. Internally, Findr.jl operates on matrices, and if you have an expression DataFrame df, then Matrix(df) should return a matrix of floats.\nAt the moment, Findr.jl does not support count-based expression data being provided as a DataFrame of integers. This is not an intrinsic limitation of the method, but simply to distinguish expression data from integer-valued genotype data. Future versions will remove this limitation by supporting scientific types.\nThis tutorial uses two tables of expression data from the same set of samples, one for mRNA expression data called dt, and one for microRNA (miRNA) expression data called dm:\n\ndt = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dt.arrow\")));\ndm = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dm.arrow\")));\n\n\n\nThe mRNA data has expression data for 23722 genes in 360 samples, while miRNA data is available for 674 miRNAs in the same 360 samples.\n\n\nWe can confirm that the data frames are of the right type:\n\n[typeof(Matrix(dt)) typeof(Matrix(dm))]\n\n1×2 Matrix{DataType}:\n Matrix{Float64}  Matrix{Float64}"
  },
  {
    "objectID": "coexpression.html#run-findr.jl",
    "href": "coexpression.html#run-findr.jl",
    "title": "Coexpression analysis",
    "section": "Run Findr.jl",
    "text": "Run Findr.jl\n\nAll-vs-all coexpression analysis\nThe simplest type of coexpression analysis tests for non-zero correlation among all possible pairs in a gene expression dataset. Let’s do this for the miRNA data:\n\ndP_mir_all = findr(dm, FDR=0.05)\n\n28323×4 DataFrame28298 rows omitted\n\n\n\nRow\nSource\nTarget\nProbability\nqvalue\n\n\n\nString\nString\nFloat64\nFloat64\n\n\n\n\n1\nhsa-miR-574-3p\nhsa-miR-574-5p\n1.0\n0.0\n\n\n2\nhsa-miR-4482-1-3p\nhsa-miR-1304-3p\n1.0\n0.0\n\n\n3\nhsa-miR-3667-5p\nhsa-miR-3667-3p\n1.0\n0.0\n\n\n4\nhsa-miR-550a-2-5p\nhsa-miR-550a-2-3p\n1.0\n0.0\n\n\n5\nhsa-miR-550a-2-5p\nhsa-miR-550a-3-5p\n1.0\n0.0\n\n\n6\nhsa-miR-3130-2-5p\nhsa-miR-3130-1-5p\n1.0\n0.0\n\n\n7\nhsa-let-7b-5p\nhsa-let-7b-3p\n1.0\n0.0\n\n\n8\nhsa-miR-96-5p\nhsa-miR-182-5p\n1.0\n0.0\n\n\n9\nhsa-miR-96-5p\nhsa-miR-1271-5p\n1.0\n0.0\n\n\n10\nhsa-miR-3667-3p\nhsa-miR-3667-5p\n1.0\n0.0\n\n\n11\nhsa-miR-181c-5p\nhsa-miR-181c-3p\n1.0\n0.0\n\n\n12\nhsa-miR-181c-5p\nhsa-miR-181d-5p\n1.0\n0.0\n\n\n13\nhsa-miR-335-5p\nhsa-miR-335-3p\n1.0\n0.0\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n28312\nhsa-miR-454-3p\nhsa-miR-3688-1-3p\n0.849358\n0.0499582\n\n\n28313\nhsa-miR-3960-3p\nhsa-miR-551b-3p\n0.849358\n0.0499618\n\n\n28314\nhsa-miR-16-1-5p\nhsa-miR-4437-3p\n0.849352\n0.0499654\n\n\n28315\nhsa-miR-1180-3p\nhsa-miR-3181-5p\n0.849348\n0.0499689\n\n\n28316\nhsa-miR-92a-2-3p\nhsa-miR-548o-2-3p\n0.849322\n0.0499725\n\n\n28317\nhsa-miR-27b-3p\nhsa-miR-642a-5p\n0.849285\n0.049976\n\n\n28318\nhsa-miR-1303-5p\nhsa-miR-92a-2-3p\n0.849272\n0.0499796\n\n\n28319\nhsa-miR-191-5p\nhsa-miR-320c-2-3p\n0.84927\n0.0499831\n\n\n28320\nhsa-miR-142-3p\nhsa-miR-365a-5p\n0.849264\n0.0499867\n\n\n28321\nhsa-miR-374a-3p\nhsa-miR-20a-5p\n0.849261\n0.0499903\n\n\n28322\nhsa-miR-98-3p\nhsa-miR-548k-5p\n0.849259\n0.0499938\n\n\n28323\nhsa-miR-28-5p\nhsa-miR-181d-5p\n0.849217\n0.0499974\n\n\n\n\n\n\nFindr computes a posterior probability of non-zero correlation for every Source and Target gene pair. By default the output is sorted by decreasing Probability and self-interactions are excluded. The optional parameter FDR can be used to limit the output to the set of pairs that has a global false discovery rate (FDR) less than a desired value. The qvalue column in the output can be used for further filtering of the output. Say you ran findr with an FRD threshold of 5% as above. If you now want to restrict the output to an FDR threshold of 1%, you can do:\n\nfilter!(row -&gt; row.qvalue &lt;= 0.01, dP_mir_all)\n\n14479×4 DataFrame14454 rows omitted\n\n\n\nRow\nSource\nTarget\nProbability\nqvalue\n\n\n\nString\nString\nFloat64\nFloat64\n\n\n\n\n1\nhsa-miR-574-3p\nhsa-miR-574-5p\n1.0\n0.0\n\n\n2\nhsa-miR-4482-1-3p\nhsa-miR-1304-3p\n1.0\n0.0\n\n\n3\nhsa-miR-3667-5p\nhsa-miR-3667-3p\n1.0\n0.0\n\n\n4\nhsa-miR-550a-2-5p\nhsa-miR-550a-2-3p\n1.0\n0.0\n\n\n5\nhsa-miR-550a-2-5p\nhsa-miR-550a-3-5p\n1.0\n0.0\n\n\n6\nhsa-miR-3130-2-5p\nhsa-miR-3130-1-5p\n1.0\n0.0\n\n\n7\nhsa-let-7b-5p\nhsa-let-7b-3p\n1.0\n0.0\n\n\n8\nhsa-miR-96-5p\nhsa-miR-182-5p\n1.0\n0.0\n\n\n9\nhsa-miR-96-5p\nhsa-miR-1271-5p\n1.0\n0.0\n\n\n10\nhsa-miR-3667-3p\nhsa-miR-3667-5p\n1.0\n0.0\n\n\n11\nhsa-miR-181c-5p\nhsa-miR-181c-3p\n1.0\n0.0\n\n\n12\nhsa-miR-181c-5p\nhsa-miR-181d-5p\n1.0\n0.0\n\n\n13\nhsa-miR-335-5p\nhsa-miR-335-3p\n1.0\n0.0\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n14468\nhsa-miR-18a-3p\nhsa-miR-23a-5p\n0.961873\n0.00997817\n\n\n14469\nhsa-miR-181a-1-3p\nhsa-miR-192-3p\n0.961868\n0.00998012\n\n\n14470\nhsa-miR-324-5p\nhsa-miR-362-5p\n0.961868\n0.00998207\n\n\n14471\nhsa-miR-138-1-3p\nhsa-miR-30c-1-5p\n0.961849\n0.00998401\n\n\n14472\nhsa-miR-598-3p\nhsa-miR-22-3p\n0.96184\n0.00998596\n\n\n14473\nhsa-miR-148b-3p\nhsa-miR-3136-5p\n0.961824\n0.00998791\n\n\n14474\nhsa-miR-19a-5p\nhsa-miR-92a-1-5p\n0.961823\n0.00998985\n\n\n14475\nhsa-miR-142-3p\nhsa-miR-4645-3p\n0.96181\n0.0099918\n\n\n14476\nhsa-miR-197-3p\nhsa-let-7f-1-5p\n0.961799\n0.00999375\n\n\n14477\nhsa-miR-125a-5p\nhsa-miR-10a-5p\n0.961778\n0.0099957\n\n\n14478\nhsa-miR-29c-3p\nhsa-miR-548au-5p\n0.961769\n0.00999765\n\n\n14479\nhsa-miR-619-5p\nhsa-miR-1307-3p\n0.961766\n0.0099996\n\n\n\n\n\n\nNote that the filter! command modifies the input DataFrame in-place, that is, the rows not matching the selection criteria are deleted. Use filter to return a new DataFrame with the selected rows.\nFinally, remember that the output of coexpression analysis in Findr is not symmetric, that is\n\\[\nP(Source, Target) \\neq P(Target, Source)\n\\]\nThis is because the posterior probabilities are estimated using a Source-specific background distribution, accounting for the fact that different genes may have a different number of non-null interaction partners a priori. See the Findr paper for details.\n\n\nBipartite coexpression analysis\nSince Findr’s posterior probabilities are Source gene-specific, we may be interested in computing probabilities only for a subset of Source genes, or using different Source and Target gene sets.\nAs an example of the first scenario, assume we are interested in finding microRNAs that are significantly correlated with microRNAs from the Mir-200 family. First find the Mir-200 microRNAs:\n\nmir200 = names(dm)[startswith.(names(dm),\"hsa-miR-200\")]\n\n3-element Vector{String}:\n \"hsa-miR-200b-3p\"\n \"hsa-miR-200a-3p\"\n \"hsa-miR-200c-3p\"\n\n\nThen run\n\ndP_mir200_mir = findr(dm, colnames=mir200, FDR=0.01)\n\n47×4 DataFrame22 rows omitted\n\n\n\nRow\nSource\nTarget\nProbability\nqvalue\n\n\n\nString\nString\nFloat64\nFloat64\n\n\n\n\n1\nhsa-miR-200b-3p\nhsa-miR-200a-3p\n1.0\n2.76053e-9\n\n\n2\nhsa-miR-200a-3p\nhsa-miR-200b-3p\n1.0\n2.80845e-9\n\n\n3\nhsa-miR-200c-3p\nhsa-miR-93-5p\n0.999998\n6.30622e-7\n\n\n4\nhsa-miR-200c-3p\nhsa-miR-140-3p\n0.999983\n4.80667e-6\n\n\n5\nhsa-miR-200b-3p\nhsa-miR-429-3p\n0.999907\n2.25115e-5\n\n\n6\nhsa-miR-200c-3p\nhsa-miR-16-1-5p\n0.999782\n5.5108e-5\n\n\n7\nhsa-miR-200c-3p\nhsa-miR-664-3p\n0.999774\n7.95436e-5\n\n\n8\nhsa-miR-200c-3p\nhsa-miR-17-5p\n0.999627\n0.000116234\n\n\n9\nhsa-miR-200c-3p\nhsa-miR-769-5p\n0.999219\n0.000190152\n\n\n10\nhsa-miR-200b-3p\nhsa-miR-582-3p\n0.999196\n0.000251556\n\n\n11\nhsa-miR-200c-3p\nhsa-miR-130b-5p\n0.999114\n0.000309265\n\n\n12\nhsa-miR-200c-3p\nhsa-miR-425-5p\n0.999025\n0.00036474\n\n\n13\nhsa-miR-200c-3p\nhsa-miR-103a-2-3p\n0.998972\n0.000415735\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n36\nhsa-miR-200b-3p\nhsa-miR-769-3p\n0.983903\n0.00641045\n\n\n37\nhsa-miR-200c-3p\nhsa-miR-378a-3p\n0.983249\n0.00668992\n\n\n38\nhsa-miR-200b-3p\nhsa-miR-26b-5p\n0.981344\n0.00700482\n\n\n39\nhsa-miR-200c-3p\nhsa-miR-619-5p\n0.980996\n0.00731249\n\n\n40\nhsa-miR-200c-3p\nhsa-miR-500a-5p\n0.979841\n0.00763364\n\n\n41\nhsa-miR-200c-3p\nhsa-miR-4677-3p\n0.979659\n0.00794358\n\n\n42\nhsa-miR-200b-3p\nhsa-miR-328-3p\n0.979322\n0.00824677\n\n\n43\nhsa-miR-200b-3p\nhsa-miR-9-1-5p\n0.979034\n0.00854257\n\n\n44\nhsa-miR-200c-3p\nhsa-miR-141-5p\n0.978564\n0.00883559\n\n\n45\nhsa-miR-200c-3p\nhsa-miR-30e-3p\n0.97794\n0.00912946\n\n\n46\nhsa-miR-200a-3p\nhsa-miR-26b-5p\n0.972919\n0.00951972\n\n\n47\nhsa-miR-200b-3p\nhsa-miR-93-5p\n0.971509\n0.00992335\n\n\n\n\n\n\nThe parameter colnames must be a vector of strings containing a subset of variable names of the input DataFrame dm to be used as Source genes.\nAs an example of the second scenario, we may be interested in finding genes that are significantly correlated with all or a subset of microRNAs:\n\ndP_mir_mrna = findr(dt, dm, FDR=0.01)\n\n52031×4 DataFrame52006 rows omitted\n\n\n\nRow\nSource\nTarget\nProbability\nqvalue\n\n\n\nString\nString\nFloat64\nFloat64\n\n\n\n\n1\nhsa-let-7b-5p\nENSG00000197182.8\n1.0\n0.0\n\n\n2\nhsa-let-7b-5p\nENSG00000241990.1\n1.0\n0.0\n\n\n3\nhsa-miR-335-5p\nENSG00000106484.8\n1.0\n0.0\n\n\n4\nhsa-miR-335-5p\nENSG00000128510.5\n1.0\n0.0\n\n\n5\nhsa-miR-335-5p\nENSG00000220884.2\n1.0\n0.0\n\n\n6\nhsa-miR-618-5p\nENSG00000111052.3\n1.0\n0.0\n\n\n7\nhsa-miR-335-3p\nENSG00000106484.8\n1.0\n0.0\n\n\n8\nhsa-miR-335-3p\nENSG00000128510.5\n1.0\n0.0\n\n\n9\nhsa-miR-335-3p\nENSG00000220884.2\n1.0\n0.0\n\n\n10\nhsa-miR-138-1-3p\nENSG00000261786.1\n1.0\n0.0\n\n\n11\nhsa-miR-143-3p\nENSG00000249959.1\n1.0\n0.0\n\n\n12\nhsa-miR-151a-3p\nENSG00000169398.14\n1.0\n0.0\n\n\n13\nhsa-miR-151a-5p\nENSG00000169398.14\n1.0\n0.0\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n52020\nhsa-miR-181b-1-5p\nENSG00000220785.3\n0.973752\n0.00999638\n\n\n52021\nhsa-miR-2116-3p\nENSG00000249274.1\n0.973752\n0.00999669\n\n\n52022\nhsa-miR-184-3p\nENSG00000258749.1\n0.973749\n0.00999701\n\n\n52023\nhsa-miR-582-5p\nENSG00000214389.2\n0.973748\n0.00999732\n\n\n52024\nhsa-miR-4424-3p\nENSG00000225507.1\n0.973748\n0.00999763\n\n\n52025\nhsa-miR-150-3p\nENSG00000243014.1\n0.973748\n0.00999794\n\n\n52026\nhsa-miR-128-1-5p\nENSG00000168234.6\n0.973747\n0.00999826\n\n\n52027\nhsa-miR-3176-3p\nENSG00000063322.6\n0.973747\n0.00999857\n\n\n52028\nhsa-miR-146a-5p\nENSG00000214193.5\n0.973747\n0.00999888\n\n\n52029\nhsa-miR-181c-3p\nENSG00000128692.7\n0.973747\n0.00999919\n\n\n52030\nhsa-miR-22-3p\nENSG00000236285.1\n0.973746\n0.0099995\n\n\n52031\nhsa-miR-486-5p\nENSG00000160145.10\n0.973746\n0.00999982\n\n\n\n\n\n\nNote the order of the arguments: here we tested all microRNAs as \\(A\\) or Source genes (dm argument) against all mRNA transcripts as \\(B\\) or Target genes (dt argument), that is, background distributions are fitted for each microRNA (column of dm) from the log-likelihood ratios for all 23,722 mRNAs (columns of dt)."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Internal functions",
    "section": "",
    "text": "The only function exported by Findr.jl is the findr function itself. Nevertheless, many of the internal functions may be useful when digging deeper in the results for specific genes. The package documentation contains detailed descriptions of all package functions, intertwined with the methods section of the original paper, and should give a good overview of what is available. To illustrate how these functions can be used, we will reproduce the following figure (Supplementary Fig. S1 from the original paper):\n\n\n\nLLR distribution of the relevance test for hsa-miR-200b-3p on 23722 potential targets of Geuvadis dataset."
  },
  {
    "objectID": "functions.html#introduction",
    "href": "functions.html#introduction",
    "title": "Internal functions",
    "section": "",
    "text": "The only function exported by Findr.jl is the findr function itself. Nevertheless, many of the internal functions may be useful when digging deeper in the results for specific genes. The package documentation contains detailed descriptions of all package functions, intertwined with the methods section of the original paper, and should give a good overview of what is available. To illustrate how these functions can be used, we will reproduce the following figure (Supplementary Fig. S1 from the original paper):\n\n\n\nLLR distribution of the relevance test for hsa-miR-200b-3p on 23722 potential targets of Geuvadis dataset."
  },
  {
    "objectID": "functions.html#set-up-the-environment",
    "href": "functions.html#set-up-the-environment",
    "title": "Internal functions",
    "section": "Set up the environment",
    "text": "Set up the environment\n\nusing DrWatson\nquickactivate(@__DIR__)\n\nusing DataFrames\nusing Arrow\nusing StatsPlots\nusing LaTeXStrings\nusing Distributions\n\nusing Findr"
  },
  {
    "objectID": "functions.html#load-data",
    "href": "functions.html#load-data",
    "title": "Internal functions",
    "section": "Load data",
    "text": "Load data\nYou should by now be familiar with the GEUVADIS data used in the First steps tutorials. Here we need the following files:\n\ndt = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dt.arrow\")));\ndm = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dm.arrow\")));\ndgm = DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dgm.arrow\")));\n\nWe also need the microRNA eQTL mapping (see the causal inference tutorial):\n\ndpm = DataFrame(SNP_ID = names(dgm), GENE_ID=names(dm)[1:ncol(dgm)]);\n\nSet the microRNA of interest:\n\nmirA = \"hsa-miR-200b-3p\";"
  },
  {
    "objectID": "functions.html#run-the-analysis",
    "href": "functions.html#run-the-analysis",
    "title": "Internal functions",
    "section": "Run the analysis",
    "text": "Run the analysis\n\nConvert the data\nInternally, all Findr.jl functions use matrix-based inputs and supernormalized data. The easiest way to convert our data is to run supernormalize on the initial data:\n\nYt = Findr.supernormalize(dt);\nYm = vec(Findr.supernormalize(select(dm,mirA)));\n\nFor the genotype data, no conversion is needed:\n\nE = dgm[:, dpm.SNP_ID[dpm.GENE_ID.==mirA][1]];\n\nWe will also need the number of samples and number of genotype groups:\n\nns = length(E);\nng = length(unique(E));\n\n\n\nCompute log-likelihood ratios\nThroughout the package, the likelihood ratio tests are labelled by the following symbols\n\nTest 2 (Linkage test): :link\nTest 3 (Mediation test): :med\nTest 4 (Relevance test): :relev\nTest 5 (Pleiotropy test): :pleio\n\nSince all log-likelihood ratios are computed from the same summary statistics, a single function computes them all. To compute the log-likelihood ratios for a specific A-gene (here: hsa-miR-200b-3p with column vector of expression data Ym) with a causal instrument (best eQTL) with genotype vector E, run:\n\nllr2, llr3, llr4, llr5 = Findr.realLLR_col(Yt, Ym, E);\n\nIf you know you’re only going to use one of them, you can also run:\n\n_ , _ , llr4 , _ = Findr.realLLR_col(Yt, Ym, E);\n\n\n\nCompute posterior probabilities\nPosterior probabilities are computed by fitting a mixture model to the observed vector of log-likelihood ratios. Two fitting methods are implmented: a method of moments or using kernel density estimation. The method of moments is the default:\n\npp_mom, dmix = Findr.fit_mixdist_mom(llr4, ns, ng, :relev);\n\nThe KDE estimate is obtained similarly:\n\npp_kde = Findr.fit_mixdist_KDE(llr4, ns, ng, :relev);\n\nThe method of moments has a second output argument, dmix, a mixture model distribution object where each mixture component is an LBeta dsitribution:\n\ndmix\n\nMixtureModel{Findr.LBeta}(K = 2)\ncomponents[1] (prior = 0.7563): Findr.LBeta(α=3.0, β=356.0)\ncomponents[2] (prior = 0.2437): Findr.LBeta(α=4.8444856311440025, β=283.963310322944)\n\n\nThe first component in the mixture model is the null distribution, which can also be created as follows:\n\ndnull = Findr.nulldist(ns,ng,:relev)\n\nFindr.LBeta(α=3.0, β=356.0)\n\n\nThe prior of the null component is the estimated proportion of truly null features in the observed log-likelihood ratio vector llr4:\n\nπ₀ = dmix.prior.p[1]\n\n0.7562600118033892\n\n\nWe can verify that both methods (moments and KDE) give similar posterior probabilities\nscatter(pp_mom,pp_kde, markersize=4)\n\n\nCompute p-values under the null hypothesis\nWe don’t need null p-values to reproduce the figure above, but they can be used to assess the quality of the \\(\\pi_0\\) estimate.\n\npnull = Findr.nullpval(llr4,ns,ng,:relev);\n\nWe can verify that the histogram shows the characteristic shape of a set of anti-conservative p-values and that \\(\\pi_0\\) correctly estimates the height of the “flat” portion of the histogram near \\(p\\approx 1\\):\n\nhistogram(pnull, normalize=:pdf, bins=100, label=\"\")\nhline!([π₀],linewidth=2, label=\"\", linecolor=:red)\nxlims!(0,1)\nxlabel!(\"Null p-value\")\nylabel!(\"Observed distribution\")\nannotate!(0.95,0.95, (L\"\\pi_0\", 18, :red))"
  },
  {
    "objectID": "functions.html#reproduce-the-figure",
    "href": "functions.html#reproduce-the-figure",
    "title": "Internal functions",
    "section": "Reproduce the figure",
    "text": "Reproduce the figure\n\nMethod of moments estimates\nFor the method of moments, the null and real log-likelihood ratio distribution are available in the form of distribution objects, and we can simply evaluate their pdfs on a range of values:\n\nlval = range(0,maximum(llr4),500);\npnull_val = π₀ * pdf.(dnull,lval);\npreal_val = pdf.(dmix,lval);\npp_val = 1 .- pnull_val ./ preal_val;\n\nPlot the final figure:\n\nhistogram(llr4, normalize=:pdf, bins=100, color=:navajowhite1, label=\"Real data\", size=(600,450))\nplot!(lval,preal_val, linewidth=2, color=:black, label=L\"p(LLR^{(4)})\")\nplot!(lval,pnull_val, linewidth=2, color=:red, label=L\"\\pi_0 p(LLR^{(4)} \\mid \\mathcal{H}_0)\", legend=(0.25,0.95))\nylims!(0, 160)\nxlabel!(L\"LLR^{(4)}\")\nylabel!(L\"p(LLR^{(4)})\")\nplot!(twinx(),lval,pp_val, linewidth=2, color=:blue, label=\"\", yguidefontcolor=:blue, ylims=(0,1.), ylabel=L\"P(H^{(4)}_{alt} \\mid LLR^{(4)})\")\n#ylabel(L\"P(H^{(4)}_{alt} \\mid LLR^{(4)})\")\nxlims!(0,0.03)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompared to the figure at the top of the page, we see that the method of moments provides a smooth fit to the histogram and consequently also posterior probabilities that increase more smoothly with increasing LLR values.\n\n\nKDE estimates\nFor the KDE method, we don’t have a distribution object fitting the histogram. Instead with use kernel density estimation and return estimated pdf values at every value of the LLR input vector:\n\npreal_kde = Findr.fit_kde(llr4);\n\nFor plotting, we filter a relevant range of values from all vectors:\n\nrg = 1:50:length(llr4);\nt = sortperm(llr4);\nlval_kde = llr4[t][rg];\npreal_val_kde = preal_kde[t][rg];\npp_val_kde = pp_kde[t][rg];\n\nAnd plot the figure again:\n\nhistogram(llr4, normalize=:pdf, bins=100, color=:navajowhite1, label=\"Real data\", size=(600,450))\nplot!(lval_kde,preal_val_kde, linewidth=2, color=:black, label=L\"p(LLR^{(4)})\")\nplot!(lval,pnull_val, linewidth=2, color=:red, label=L\"\\pi_0 p(LLR^{(4)} \\mid \\mathcal{H}_0)\", legend=(0.25,0.95))\nylims!(0, 160)\nxlabel!(L\"LLR^{(4)}\")\nylabel!(L\"p(LLR^{(4)})\")\nplot!(twinx(),lval_kde,pp_val_kde, linewidth=2, color=:blue, label=\"\", yguidefontcolor=:blue, ylims=(0,1.), ylabel=L\"P(H^{(4)}_{alt} \\mid LLR^{(4)})\")\n#ylabel(L\"P(H^{(4)}_{alt} \\mid LLR^{(4)})\")\nxlims!(0,0.03)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Findr Tutorials",
    "section": "",
    "text": "Welcome to a set of tutorials for the Findr.jl package, an implementation of the Findr software in Julia. Findr is a software package for coexpression analysis, association analysis, and causal inference from multi-omics data.\nThe methods implemented in Findr were developed by Lingfei Wang and Tom Michoel, and were first described in the paper “Efficient and accurate causal inference with hidden confounders from genome-transcriptome variation data”.\nThese tutorials should be read alongside the Findr.jl documentation. Make sure to read the installation instructions if you want to run these tutorials locally."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "To install Julia, follow the Getting Started instructions."
  },
  {
    "objectID": "installation.html#install-julia",
    "href": "installation.html#install-julia",
    "title": "Installation",
    "section": "",
    "text": "To install Julia, follow the Getting Started instructions."
  },
  {
    "objectID": "installation.html#install-quarto-optional",
    "href": "installation.html#install-quarto-optional",
    "title": "Installation",
    "section": "Install Quarto (optional)",
    "text": "Install Quarto (optional)\nThese tutorials are written in Quarto. You don’t need Quarto if you only want to play with the notebooks, but you will need it if you want to reprodcue this website locally. See the Get Started page for installation instructions."
  },
  {
    "objectID": "installation.html#install-the-julia-extension-for-your-favourite-editoride-optional",
    "href": "installation.html#install-the-julia-extension-for-your-favourite-editoride-optional",
    "title": "Installation",
    "section": "Install the Julia extension for your favourite editor/IDE (optional)",
    "text": "Install the Julia extension for your favourite editor/IDE (optional)\nExtensions or plugings for VS Code, Emacs, and VIM are linked from the Julia homepage"
  },
  {
    "objectID": "installation.html#install-ijulia",
    "href": "installation.html#install-ijulia",
    "title": "Installation",
    "section": "Install IJulia",
    "text": "Install IJulia\nTo run the tutorial notebooks, you need IJulia. If you installed Quarto, follow these instructions to make sure Quarto can use IJulia to render documents with embedded Julia code."
  },
  {
    "objectID": "installation.html#install-findr.jl",
    "href": "installation.html#install-findr.jl",
    "title": "Installation",
    "section": "Install Findr.jl",
    "text": "Install Findr.jl\nFindr.jl is not yet a registered package. To install it, follow the instructions for adding unregistered packages. If you’re new to using Pkg, Julia’s package manager, see the Getting Started notes.\nOpen a Julia console and enter the Pkg REPL by pressing ] from the Julia REPL. Then:\npkg&gt; add https://github.com/tmichoel/Findr.jl\nor if you want to use the SSH-based git protocol:\npkg&gt; add \"git@github.com:tmichoel/Findr.jl.git\""
  },
  {
    "objectID": "installation.html#install-the-findrtutorials-repository",
    "href": "installation.html#install-the-findrtutorials-repository",
    "title": "Installation",
    "section": "Install the FindrTutorials repository",
    "text": "Install the FindrTutorials repository\nThe FindrTutorials repository uses DrWatson to make a reproducible scientific project named\n\nFindrTutorials\n\nTo (locally) reproduce this project, do the following:\n\nDownload this code base. Notice that raw data are not included in the git-history and need to be downloaded independently (see below).\nOpen a Julia console and do:\njulia&gt; using Pkg\njulia&gt; Pkg.add(\"DrWatson\") # install globally, for using `quickactivate`\njulia&gt; Pkg.activate(\"path/to/this/project\")\njulia&gt; Pkg.instantiate()\n\nThis will install all necessary packages for you to be able to run the scripts and everything should work out of the box, including correctly finding local paths.\nYou may notice that most scripts start with the commands:\nusing DrWatson\n@quickactivate \"FindrTutorials\"\nwhich auto-activate the project and enable local path handling from DrWatson."
  },
  {
    "objectID": "installation.html#download-and-preprocess-data",
    "href": "installation.html#download-and-preprocess-data",
    "title": "Installation",
    "section": "Download and preprocess data",
    "text": "Download and preprocess data\nThe scripts folder of the project contains a number of files named process_data_*. After downloading the initial data files (see below), you can then run the script to produce processed data files in the Apache Arrow format, which will be stored in the exp_pro folder.\n\nGEUVADIS data\n\nDownload preprocessed data files from the GEUVADIS study.\nSave all files in the folder exp_raw/findr-data-geuvadis.\nConcatenate the transcript files:\n$ cat dt1.csv.gz dt2.csv.gz &gt; dt.csv.gz\nUnzip all .gz files.\nCreate a folder exp_pro/findr-data-geuvadis (sorry, not very clean that this isn’t automated).\nRun the script process_data_findr-data-geuvadis.jl. You can either run it from the command line:\n$ julia scripts/process_data_findr-data-geuvadis.jl\nor open the file and run it interactively in your editor/IDE of choice. See Running Code for more information about how to this in VS Code.\nVerify that the directory exp_pro/findr-data-geuvadis contains matched .arrow files for each .csv file in the exp_raw/findr-data-geuvadis folder."
  },
  {
    "objectID": "installation.html#run-the-tutorials",
    "href": "installation.html#run-the-tutorials",
    "title": "Installation",
    "section": "Run the tutorials",
    "text": "Run the tutorials\nYou are now all set up to run the tutorials. You can either work directly with the *.qmd files in the website folder, or use the jupyter notebooks (*.ipynb files) in the notebooks folder. Make sure to have IJulia installed if using the latter option."
  },
  {
    "objectID": "matrix-data.html",
    "href": "matrix-data.html",
    "title": "Matrix-based data",
    "section": "",
    "text": "Internally, all Findr.jl functions work with matrices or array-based data, and the DataFrame based findr methods used in the coexpression analysis, association analysis, and causal inference tutorials are wrapper functions provided for convenience. If you prefer matrix-based data over DataFrames, you can directly use matrix-based findr methods without having to create DataFrames first."
  },
  {
    "objectID": "matrix-data.html#introduction",
    "href": "matrix-data.html#introduction",
    "title": "Matrix-based data",
    "section": "",
    "text": "Internally, all Findr.jl functions work with matrices or array-based data, and the DataFrame based findr methods used in the coexpression analysis, association analysis, and causal inference tutorials are wrapper functions provided for convenience. If you prefer matrix-based data over DataFrames, you can directly use matrix-based findr methods without having to create DataFrames first."
  },
  {
    "objectID": "matrix-data.html#set-up-the-environment",
    "href": "matrix-data.html#set-up-the-environment",
    "title": "Matrix-based data",
    "section": "Set up the environment",
    "text": "Set up the environment\n\nusing DrWatson\nquickactivate(@__DIR__)\n\nusing DataFrames\nusing Arrow\n\nusing Findr"
  },
  {
    "objectID": "matrix-data.html#load-data",
    "href": "matrix-data.html#load-data",
    "title": "Matrix-based data",
    "section": "Load data",
    "text": "Load data\nLet’s pretend our GEUVADIS data is in a matrix-based format:\n\nXt = Matrix(DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dt.arrow\"))));\nXm = Matrix(DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dm.arrow\"))));\nGm = Matrix(DataFrame(Arrow.Table(datadir(\"exp_pro\",\"findr-data-geuvadis\", \"dgm.arrow\"))));\n\nWe also need the microRNA eQTL mapping (see the causal inference tutorial), in this case in the form of an array where each row corresponds to a cis-eQTL/eGene pair represented by of a column index of Gm (i.e. a SNP) and a column index of Xm (i.e. a microRNA). Recall that due to the preprocessing of the findr-geuvadis data. the column indices are identical, but this will not be the case in general:\n\nmirpairs = zeros(Int32,size(Gm,2),2);\nfor k=1:size(mirpairs,1)\n    mirpairs[k,:] = [k k]\nend\n\nNote that data must be stored in matrices where columns correspond to variables (genes, SNPs, etc.) and rows correspond to observations (samples)."
  },
  {
    "objectID": "matrix-data.html#run-findr.jl",
    "href": "matrix-data.html#run-findr.jl",
    "title": "Matrix-based data",
    "section": "Run Findr.jl",
    "text": "Run Findr.jl\nBelow, we only show the relevant findr commands. Check the corresponding tutorials and Findr.jl documentation for more details.\n\nCoexpression analysis\n\nAll-vs-all\nCoexpression analysis on a single matrix returns a square matrix with dimensions equal to the number of variables (columns) in the input matrix:\n\nP = findr(Xm)\n\n674×674 Matrix{Float64}:\n 1.0         0.0197072    0.225709   …  0.0332835  0.109018   0.106084\n 0.0649505   1.0          0.0931958     0.0475433  0.733006   0.248782\n 0.182571    0.0161952    1.0           0.777922   0.108028   0.1005\n 0.00185799  0.078849     0.0794521     0.0700811  0.0996734  0.123286\n 0.109671    0.0852573    0.239883      0.0346806  0.166101   0.298598\n 0.0323098   0.0302238    0.0587378  …  0.569455   0.105368   0.186618\n 0.466356    0.0116614    0.087737      0.043641   0.126047   0.0943835\n 0.0233157   0.00802049   0.56947       0.0551034  0.34866    0.0983946\n 0.101298    0.00280115   0.135996      0.0440159  0.193652   0.131925\n 0.187731    0.535853     1.0           0.0338527  0.214703   0.134344\n 0.401814    0.136546     0.433783   …  0.0333494  0.16544    0.188016\n 0.195701    0.0226562    0.0287868     0.0539721  0.10707    0.161418\n 0.695515    0.00794346   0.453652      0.111576   0.283267   0.0973275\n ⋮                                   ⋱                        \n 0.0484937   0.0184506    0.872223      0.0379798  0.100317   0.157875\n 0.205802    0.115677     0.105303      0.0335587  0.381738   0.517292\n 0.42119     0.000699482  0.969754      0.0334589  0.220487   0.0974999\n 0.0699346   0.00138171   0.112064   …  0.0447547  0.112793   0.0956179\n 0.12073     0.00940378   0.79598       0.0367054  0.192191   0.093996\n 0.10299     0.0284845    0.046016      0.0331139  0.245189   0.124241\n 0.0109064   0.0244777    0.174158      0.0621861  0.112385   0.817952\n 0.321733    0.110006     0.0977148     0.0362147  0.114087   0.153156\n 0.169049    0.168306     0.0968118  …  0.999704   0.117747   0.0954134\n 0.0148231   0.0981611    0.907828      1.0        0.123624   0.912876\n 0.0692175   0.738789     0.099484      0.0426253  1.0        1.0\n 0.0777971   0.339845     0.0903338     0.797384   1.0        1.0\n\n\nIn the output, columns correspond to A-genes (causal factors) and rows to B-genes (targets), that is:\n\\[\nP_{i,j} = P(X_j \\to X_i)\n\\]\nNote that the diagonal is arbitrarily set to one, Findr cannot make any inferences about the presence or absence of self-regulation!\n\n\nBipartite\nAnalyse coexpression from a subset of variables to the whole set:\n\nP = findr(Xm; cols=[1,3,7,50])\n\n674×4 Matrix{Float64}:\n 1.0         0.225709   0.409288   0.242541\n 0.0649505   0.0931958  0.0636956  0.154539\n 0.182571    1.0        0.067289   0.0618777\n 0.00185799  0.0794521  0.160056   0.481415\n 0.109671    0.239883   0.312803   0.0509264\n 0.0323098   0.0587378  0.0264131  0.0405768\n 0.466356    0.087737   1.0        0.198557\n 0.0233157   0.56947    0.263707   0.114162\n 0.101298    0.135996   0.0171641  0.233525\n 0.187731    1.0        0.126453   0.10633\n 0.401814    0.433783   0.0676799  0.288999\n 0.195701    0.0287868  0.0967082  0.138005\n 0.695515    0.453652   0.13247    0.259272\n ⋮                                 \n 0.0484937   0.872223   0.340024   0.522543\n 0.205802    0.105303   0.335258   0.103468\n 0.42119     0.969754   0.2815     0.120862\n 0.0699346   0.112064   0.25883    0.323375\n 0.12073     0.79598    0.124066   0.282935\n 0.10299     0.046016   0.51225    0.236598\n 0.0109064   0.174158   0.14438    0.299121\n 0.321733    0.0977148  0.188552   0.397318\n 0.169049    0.0968118  0.0382886  0.351039\n 0.0148231   0.907828   0.142995   0.0562642\n 0.0692175   0.099484   0.142748   0.0136591\n 0.0777971   0.0903338  0.0149468  0.380175\n\n\nAnalyse coexpression from the variables in Xm to the variables in Xt:\n\nP = findr(Xt,Xm)\n\n23722×674 Matrix{Float64}:\n 0.00400739   0.0         0.747615     …  0.00195771   0.0541561\n 0.00103875   0.00883145  0.4872          0.0813478    0.107062\n 0.0059461    0.0         0.357284        0.0685684    0.0581842\n 0.46758      0.0         0.634931        0.136805     0.0436366\n 0.00128052   0.0         0.0216848       0.120345     0.711452\n 0.0295149    0.00883145  0.28128      …  0.0726776    0.847095\n 1.39584e-6   0.0158817   0.300538        0.00144828   0.177948\n 0.115171     0.0         0.132252        0.0427649    0.0407486\n 0.00041855   0.0         0.273877        0.0129385    0.381245\n 0.00223831   0.00883145  0.000626261     0.00137152   0.275221\n 4.42713e-5   0.00883145  0.469129     …  0.00241127   0.00558805\n 0.0407525    0.0         0.550892        0.000342252  0.0564657\n 0.000116842  0.0         0.537246        0.586175     0.990271\n ⋮                                     ⋱               \n 0.125664     0.0         0.955045     …  0.151681     0.37233\n 0.00304995   0.0601222   0.130833        0.000222891  0.138894\n 0.00687407   0.00883145  0.223432        0.0256436    0.478179\n 0.0728993    0.0         0.00866493      0.00403885   0.0540484\n 0.0855197    0.0513282   0.0858086       0.0817211    0.338614\n 0.000785811  0.0         0.114199     …  0.0128781    0.237762\n 0.0464354    0.0         0.0533607       0.0390192    0.0310723\n 0.00266738   0.00883145  0.106648        0.0413058    0.165718\n 0.000126444  0.0         0.000149911     0.0401501    0.139841\n 0.00192732   0.0         0.00752661      0.0163761    0.0417349\n 0.0203562    0.0         0.0341125    …  0.0190751    0.237147\n 0.124532     0.0         0.0207975       0.174169     0.453847\n\n\n\n\n\nAssociation analysis\nTesting associations between eQTL genotypes in Gmand microRNA expression levels in Xm:\n\nP = findr(Xm,Gm)\n\n674×55 Matrix{Float64}:\n 0.853201    0.356346  0.0       0.0  …  0.000797726  0.0  0.00224096\n 0.120473    0.99982   0.0       0.0     0.00129051   0.0  0.00585794\n 0.0925184   0.124446  1.0       0.0     0.000784934  0.0  0.00954639\n 0.0202679   0.47438   0.0       1.0     0.000733876  0.0  0.00263948\n 0.0623391   0.449505  0.0       0.0     0.00114391   0.0  0.00194524\n 0.0767795   0.377259  0.0       0.0  …  0.0028452    0.0  0.00227388\n 0.0271901   0.396912  0.0       0.0     0.00125577   0.0  1.0\n 0.0274731   0.328489  0.0       0.0     0.00373303   0.0  0.0124102\n 0.0619347   0.148897  0.0       0.0     0.00112504   0.0  0.00539071\n 0.151423    0.403371  0.999825  0.0     0.00286934   0.0  0.00362802\n 0.042108    0.446897  0.0       0.0  …  0.00162458   0.0  0.00890627\n 0.0384388   0.272137  0.0       0.0     0.00175638   0.0  0.00188658\n 0.101742    0.391688  0.0       0.0     0.000633432  0.0  0.00520416\n ⋮                                    ⋱                    \n 0.0655423   0.338839  0.0       0.0     0.000639091  0.0  0.00984286\n 0.0298992   0.188951  0.0       0.0     0.00104907   0.0  0.00429909\n 0.0510288   0.171986  0.0       0.0     0.000694162  0.0  0.00375726\n 0.123656    0.196914  0.0       0.0  …  0.00240713   0.0  0.00475791\n 0.0815461   0.162525  0.0       0.0     0.000729952  0.0  0.00578588\n 0.0486221   0.569855  0.0       0.0     0.0147248    0.0  0.0029515\n 0.0944812   0.576282  0.0       0.0     0.00105147   0.0  0.00530733\n 0.0373581   0.544132  0.0       0.0     0.00074183   0.0  0.00182359\n 0.0817629   0.586459  0.0       0.0  …  0.00190714   0.0  0.00181034\n 0.147596    0.205031  0.0       0.0     0.00176247   0.0  0.00744544\n 0.00858162  0.172087  0.0       0.0     0.000939188  0.0  0.00545941\n 0.0497977   0.264749  0.0       0.0     0.000804472  0.0  0.0824491\n\n\nIn the output, columns correspond to eQTLs and rows to genes, that is,\n\\[\nP_{i,j} = P(E_j \\to X_i)\n\\]\n\n\nCausal inference\n\nSubset-to-all\nWhen you run causal inference with findr using matrix-based inputs, the default is to return posterior probabilities for each test separately:\n\nP = findr(Xm,Gm,mirpairs);\n\nNote the dimensions of P:\n\nsize(P)\n\n(674, 4, 55)\n\n\nThe third dimension indexes the A-genes (causes), the second dimension the tests (test 2-5, see link above), and the first the B-genes (targets). If you are interested only in a specific combination, use the optional combination argument as explained in the causal inference tutorial:\n\nP = findr(Xm,Gm,mirpairs; combination=\"IV\");"
  }
]